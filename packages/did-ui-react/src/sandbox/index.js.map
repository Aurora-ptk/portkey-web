{"version":3,"file":"index.js","sources":["../utils/sandboxService/types.ts","../utils/lib.ts","../utils/sandboxService/Service.ts","../utils/errorHandler.ts","../constants/index.ts","index.ts"],"sourcesContent":["import { ChainType } from '@portkey/types';\n// import { portkeyDidUIPrefix } from '../../constants';\n\nexport enum SandboxEventTypes {\n  getBalances = '@portkey/did-ui-sdk:getBalances',\n  // View\n  callViewMethod = '@portkey/did-ui-sdk:callViewMethod',\n  // Send\n  callSendMethod = '@portkey/did-ui-sdk:callSendMethod',\n  // getEncodedTx\n  getTransactionFee = '@portkey/did-ui-sdk:getTransactionFee',\n  // getTransactionRaw\n  getTransactionRaw = 'getTransactionRaw',\n\n  callCASendMethod = '@portkey/did-ui-sdk:callCASendMethod',\n\n  callSendMethodFormat = '@portkey/did-ui-sdk:callSendMethodFormat',\n  callViewMethodFormat = '@portkey/did-ui-sdk:callViewMethodFormat',\n  encodedTx = '@portkey/did-ui-sdk:encodedTx',\n}\n\nexport enum SandboxErrorCode {\n  error,\n  success,\n} // 0 error 1 success\n\nexport type SandboxDispatchData = { code: SandboxErrorCode; message?: any };\n\nexport interface DispatchParam {\n  chainType: ChainType;\n  rpcUrl: string;\n  [x: string]: any;\n}\n","import EventEmitter from 'events';\nimport * as uuid from 'uuid';\n\nexport const eventBus = new EventEmitter();\n\nexport const isExtension = () => location.protocol === 'chrome-extension:';\n\nexport const randomId = () => uuid.v4().replace(/-/g, '');\n\nexport const dealURLLastChar = (url = '') => (url?.slice(-1) === '/' ? url.slice(0, -1) : url);\n\nexport const isBrowser = typeof window !== 'undefined';\n\n/**\n * this function is to format address,just like \"formatStr2EllipsisStr\"  to \"for...ess\"\n * @param address - address\n * @param digits - [pre_count, suffix_count]\n * @param type - format type\n * @returns string\n */\nexport const formatStr2EllipsisStr = (address = '', digits = [10, 10], type: 'middle' | 'tail' = 'middle'): string => {\n  if (!address) return '';\n\n  const len = address.length;\n\n  if (type === 'tail') return `${address.slice(0, digits[0])}...`;\n\n  if (len < digits[0] + digits[1]) return address;\n  const pre = address.substring(0, digits[0]);\n  const suffix = address.substring(len - digits[1]);\n  return `${pre}...${suffix}`;\n};\n\nexport function getExploreLink(\n  explorerUrl: string,\n  data: string,\n  type: 'transaction' | 'token' | 'address' | 'block' = 'address',\n): string {\n  const prefix = explorerUrl[explorerUrl.length - 1] !== '/' ? explorerUrl + '/' : explorerUrl;\n  switch (type) {\n    case 'transaction': {\n      return `${prefix}tx/${data}`;\n    }\n    case 'token': {\n      return `${prefix}token/${data}`;\n    }\n    case 'block': {\n      return `${prefix}block/${data}`;\n    }\n    case 'address':\n    default: {\n      return `${prefix}address/${data}`;\n    }\n  }\n}\n","import { DispatchParam, SandboxDispatchData, SandboxEventTypes } from './types';\nimport { randomId } from '../lib';\nimport { sleep } from '@portkey/utils';\n\nexport class SandboxEventService {\n  static async dispatch(event: SandboxEventTypes, data?: any, eleId = 'sandbox') {\n    let iframe: any = document.getElementById(eleId);\n    if (!iframe) {\n      await sleep(1000);\n      iframe = document.createElement('iframe');\n    }\n    const sid = randomId();\n    iframe.contentWindow.postMessage(\n      {\n        event,\n        data: { ...data, sid },\n      },\n      '*',\n    );\n    return { event, sid };\n  }\n\n  static dispatchToOrigin(event: MessageEvent<any>, data?: SandboxDispatchData) {\n    event?.source?.postMessage({ ...data, eventName: event.data.event }, event.origin as any);\n  }\n\n  static listen({ event: eventName, sid }: { event: SandboxEventTypes; sid: string }): Promise<any> {\n    return new Promise((resolve) => {\n      if (typeof window !== 'undefined')\n        window.addEventListener('message', (event) => {\n          if (event.data.eventName === eventName && event.data.sid === sid) resolve(event.data);\n        });\n    });\n  }\n  /**\n   *\n   * @param event - SandboxEventTypes\n   * @param data - when callView data is DispatchData, other any\n   * @param ele - element id\n   * @returns\n   */\n  static async dispatchAndReceive(event: SandboxEventTypes, data?: DispatchParam, eleId = 'sandbox') {\n    const dispatchKey = await SandboxEventService.dispatch(event, data, eleId);\n    return SandboxEventService.listen(dispatchKey);\n  }\n}\n","import { handleContractError } from '@portkey/contracts';\nimport { ErrorInfo, OnErrorFunc } from '../types';\nimport { message } from 'antd';\n\nexport const verifyErrorHandler = (error: any) => {\n  // let _error = isVerifyApiError(error);\n  let _error: string;\n  if (error?.type) {\n    _error = error.type;\n  } else if (typeof error === 'string') {\n    _error = error;\n  } else {\n    _error = error?.message || error?.error?.message || 'Verify error';\n  }\n  return _error;\n};\n\nexport const handleError = (error: any) => {\n  return error?.error || error;\n};\n\nexport const handleErrorMessage = (error: any, errorText?: string) => {\n  error = handleError(error);\n  error = handleContractError(error);\n  if (!error) return errorText;\n  if (typeof error === 'string') return error;\n  if (typeof error.message === 'string') return error.message;\n  return errorText;\n};\n\nexport const handleErrorCode = (error: any) => {\n  return handleError(error)?.code;\n};\n\nexport const contractErrorHandler = (error: any) => {\n  if (typeof error === 'string') return error;\n  return error?.Error?.Message || error?.message?.Message || error?.message || error?.Error;\n};\n\nexport const errorTip = (errorInfo: ErrorInfo, isShowTip?: boolean, onError?: OnErrorFunc) => {\n  const msgError = errorInfo?.error?.error?.message || errorInfo?.error?.message || errorInfo?.error;\n  if (isShowTip) msgError && message.error(msgError);\n  onError?.(errorInfo);\n};\n\nexport const getMissParams = (obj: object): string | undefined => {\n  let _key;\n  Object.entries(obj)\n    .reverse()\n    .map(([key, value]) => {\n      if (!value) _key = key;\n    });\n  return _key;\n};\n","import { aelf } from '@portkey/utils';\nexport const COMMON_PRIVATE = 'f6e512a3c259e5f9af981d7f99d245aa5bc52fe448495e0b0dd56e8406be6f71';\n\nexport const SECOND = 1000;\nexport const MINUTE = SECOND * 60;\nexport const HOUR = MINUTE * 60;\nexport const DAY = HOUR * 24;\n\nexport const commonAccount = aelf.getWallet(COMMON_PRIVATE);\nexport const portkeyDidUIPrefix = '@portkey/did-ui-sdk:';\n\nexport const PIC_SMALL_SIZE = 144;\nexport const PIC_MIDDLE_SIZE = 294;\nexport const PIC_LARGE_SIZE = 1008;\n\nexport const PAGESIZE_10 = 10;\n\nexport const DEFAULT_AMOUNT = 0;\nexport const DEFAULT_DECIMAL = 8;\nexport const DEFAULT_DIGITS = 4;\n\nexport const WEB_PAGE = 'https://openlogin.portkey.finance';\n// export const WEB_PAGE = 'https://openlogin-test.portkey.finance';\n// export const WEB_PAGE = 'http://localhost:3000';\n","import { SandboxEventTypes, SandboxEventService, SandboxErrorCode } from '../utils/sandboxService';\nimport { aelf } from '@portkey/utils';\nimport { FetchRequest } from '@portkey/request';\nimport { IEOAInstanceOptions, IPortkeyContract, getContractBasic } from '@portkey/contracts';\nimport { getMissParams, handleErrorMessage } from '../utils/errorHandler';\nimport { COMMON_PRIVATE } from '../constants';\nimport { IContract } from '@portkey/types';\nimport { ICustomViewOptions, IWalletCustomSendOptions } from '../utils/sandboxUtil/types';\n\ntype SendBack = (\n  event: MessageEvent<any>,\n  response?: {\n    code: SandboxErrorCode;\n    message?: any;\n    sid: string;\n    error?: any;\n    transactionId?: string;\n  },\n) => void;\ntype RpcUrl = string;\ntype ContractAddress = string;\ntype CAFlag = string; // `${contractAddress}-${caHash}`\ntype FromAccountPrivateKey = string;\nconst contracts: Record<RpcUrl, Record<ContractAddress, IContract>> = {};\nconst accountContracts: Record<RpcUrl, Record<FromAccountPrivateKey, Record<ContractAddress, IPortkeyContract>>> = {};\nconst caContracts: Record<RpcUrl, Record<FromAccountPrivateKey, Record<CAFlag, IContract>>> = {};\n\nclass SandboxUtil {\n  constructor() {\n    this.listener();\n  }\n\n  static callback(\n    event: MessageEvent<any>,\n    response?: {\n      code: SandboxErrorCode;\n      message?: any;\n      sid: string;\n    },\n  ) {\n    SandboxEventService.dispatchToOrigin(event, response);\n  }\n\n  listener() {\n    if (typeof window === 'undefined') return;\n    window.addEventListener('message', async function (event) {\n      switch (event.data.event) {\n        case SandboxEventTypes.callViewMethod:\n          SandboxUtil.callViewMethod(event, SandboxUtil.callback);\n          break;\n        case SandboxEventTypes.callSendMethod:\n          SandboxUtil.callSendMethod(event, SandboxUtil.callback);\n          break;\n        case SandboxEventTypes.callCASendMethod:\n          SandboxUtil.callCASendMethod(event, SandboxUtil.callback);\n          break;\n\n        case SandboxEventTypes.getTransactionFee:\n          SandboxUtil.getTransactionFee(event, SandboxUtil.callback);\n          break;\n\n        case SandboxEventTypes.getTransactionRaw:\n          SandboxUtil.getTransactionRaw(event, SandboxUtil.callback);\n          break;\n        case SandboxEventTypes.callSendMethodFormat:\n          SandboxUtil.callSendMethodFormat(event, SandboxUtil.callback);\n          break;\n        case SandboxEventTypes.callViewMethodFormat:\n          SandboxUtil.callViewMethodFormat(event, SandboxUtil.callback);\n          break;\n        case SandboxEventTypes.encodedTx:\n          SandboxUtil.encodedTx(event, SandboxUtil.callback);\n          break;\n        default:\n          break;\n      }\n    });\n  }\n\n  static async _getELFViewContract(rpcUrl: string, address: string, privateKey: string = COMMON_PRIVATE) {\n    let _contract = contracts?.[rpcUrl]?.[address];\n    if (!_contract) {\n      _contract = await getContractBasic({\n        contractAddress: address,\n        account: aelf.getWallet(privateKey),\n        rpcUrl,\n      });\n      if (!contracts?.[rpcUrl]) contracts[rpcUrl] = {};\n      contracts[rpcUrl][address] = _contract;\n    }\n    return _contract;\n  }\n\n  static async _getELFSendContract(rpcUrl: string, address: string, privateKey: string) {\n    let _contract = accountContracts?.[rpcUrl]?.[privateKey]?.[address];\n    if (!_contract) {\n      _contract = await getContractBasic({\n        contractAddress: address,\n        account: aelf.getWallet(privateKey),\n        rpcUrl,\n      });\n      if (!accountContracts?.[rpcUrl]) accountContracts[rpcUrl] = {};\n      if (!accountContracts?.[rpcUrl]?.[privateKey]) accountContracts[rpcUrl][privateKey] = {};\n      accountContracts[rpcUrl][privateKey][address] = _contract;\n    }\n\n    return _contract;\n  }\n\n  static async getCAContract({\n    rpcUrl,\n    privateKey,\n    caContractAddress,\n    contractAddress,\n    caHash,\n  }: {\n    caHash: string;\n    rpcUrl: string;\n    privateKey: string;\n    contractAddress: string;\n    caContractAddress: string;\n  }) {\n    let _contract = caContracts?.[rpcUrl]?.[privateKey]?.[`${contractAddress}-${caHash}`];\n    if (!_contract) {\n      _contract = await getContractBasic({\n        contractAddress,\n        account: aelf.getWallet(privateKey),\n        caContractAddress,\n        callType: 'ca',\n        caHash,\n        rpcUrl,\n      });\n      if (!caContracts?.[rpcUrl]) caContracts[rpcUrl] = {};\n      if (!caContracts?.[rpcUrl]?.[privateKey]) caContracts[rpcUrl][privateKey] = {};\n      caContracts[rpcUrl][privateKey][`${contractAddress}-${caHash}`] = _contract;\n    }\n\n    return _contract;\n  }\n\n  static async callViewMethod(event: MessageEvent<any>, callback: SendBack) {\n    const data = event.data.data ?? {};\n    try {\n      const { rpcUrl, address, methodName, paramsOption = '', chainType } = data;\n      if (!rpcUrl || !address || !methodName) throw 'Invalid argument';\n      // TODO only support aelf\n      if (chainType !== 'aelf') throw 'Not support';\n\n      const contract = await SandboxUtil._getELFViewContract(rpcUrl, address);\n      const result = await contract?.callViewMethod(methodName, paramsOption);\n      if (result.error) throw result.error;\n      callback(event, {\n        code: SandboxErrorCode.success,\n        message: result.data,\n        sid: data.sid,\n      });\n    } catch (error: any) {\n      callback(event, {\n        code: SandboxErrorCode.error,\n        error: handleErrorMessage(error),\n        sid: data.sid,\n      });\n    }\n  }\n\n  static async callCASendMethod(event: MessageEvent<any>, callback: SendBack) {\n    const data = event.data.data ?? {};\n\n    try {\n      const {\n        rpcUrl,\n        contractAddress,\n        methodName,\n        privateKey,\n        caContractAddress,\n        caHash,\n        paramsOption,\n        chainType,\n        sendOptions,\n      } = data;\n      const missParams = getMissParams({\n        rpcUrl,\n        contractAddress,\n        methodName,\n        caContractAddress,\n      });\n      if (missParams) throw `Miss Param: ${missParams}`;\n      // TODO only support aelf\n      if (chainType !== 'aelf') throw 'Not support';\n\n      const contract = await SandboxUtil.getCAContract({\n        contractAddress,\n        privateKey,\n        caContractAddress,\n        caHash,\n        rpcUrl,\n      });\n      const account = aelf.getWallet(privateKey);\n\n      const req = await contract.callSendMethod(methodName, account, paramsOption, sendOptions);\n\n      if (req?.error) throw req.error;\n      return callback(event, {\n        code: SandboxErrorCode.success,\n        message: req?.data,\n        sid: data.sid,\n        transactionId: req.transactionId,\n      });\n    } catch (e: any) {\n      callback(event, {\n        code: SandboxErrorCode.error,\n        error: handleErrorMessage(e),\n        sid: data.sid,\n      });\n    }\n  }\n\n  static async callSendMethod(event: MessageEvent<any>, callback: SendBack) {\n    const data = event.data.data ?? {};\n\n    try {\n      const { rpcUrl, address, methodName, privateKey, paramsOption, chainType, isGetSignTx = 0, sendOptions } = data;\n      const missParams = getMissParams({\n        rpcUrl,\n        address,\n        methodName,\n      });\n      if (missParams) throw `Miss Param: ${missParams}`;\n      // TODO only support aelf\n      if (chainType !== 'aelf') throw 'Not support';\n\n      const account = aelf.getWallet(privateKey);\n      const contract = await SandboxUtil._getELFSendContract(rpcUrl, address, privateKey);\n      const contractMethod = !isGetSignTx ? contract?.callSendMethod : contract?.encodedTx;\n      const req = await contractMethod?.(methodName, account, paramsOption, sendOptions);\n      if (req?.error) throw req;\n      return callback(event, { code: SandboxErrorCode.success, message: req?.data, sid: data.sid });\n    } catch (e: any) {\n      callback(event, {\n        code: SandboxErrorCode.error,\n        error: handleErrorMessage(e),\n        sid: data.sid,\n      });\n    }\n  }\n\n  static async getTransactionRaw(event: MessageEvent<any>, callback: SendBack) {\n    const data = event.data.data ?? {};\n    try {\n      const { rpcUrl, address, paramsOption, chainType, methodName, privateKey } = data;\n      if (chainType !== 'aelf') throw 'Not support';\n      const aelfContract = await SandboxUtil._getELFSendContract(rpcUrl, address, privateKey);\n      const raw = await aelfContract.encodedTx(methodName, paramsOption);\n      callback(event, {\n        code: SandboxErrorCode.success,\n        message: raw.data,\n        sid: data.sid,\n      });\n    } catch (e) {\n      return callback(event, {\n        code: SandboxErrorCode.error,\n        error: e,\n        sid: data.sid,\n      });\n    }\n  }\n\n  static async getTransactionFee(event: MessageEvent<any>, callback: SendBack) {\n    const data = event.data.data ?? {};\n    try {\n      const { rpcUrl, address, paramsOption, chainType, methodName, privateKey } = data;\n      // TODO only support aelf\n      if (chainType !== 'aelf') throw 'Not support';\n      const aelfInstance = aelf.getAelfInstance(rpcUrl);\n      const aelfContract = await SandboxUtil._getELFSendContract(rpcUrl, address, privateKey);\n      const raw = await aelf.encodedTx({\n        instance: aelfInstance,\n        contract: aelfContract,\n        functionName: methodName,\n        paramsOption,\n      });\n      if (raw.error) throw raw.error;\n      const customFetch = new FetchRequest({});\n\n      const transaction: any = await customFetch.send({\n        url: `${rpcUrl}/api/blockChain/calculateTransactionFee`,\n        method: 'POST',\n        params: {\n          RawTransaction: raw,\n        },\n      });\n\n      if (!transaction?.Success) throw 'Transaction failed';\n      callback(event, {\n        code: SandboxErrorCode.success,\n        message: transaction.TransactionFee,\n        sid: data.sid,\n      });\n    } catch (e) {\n      return callback(event, {\n        code: SandboxErrorCode.error,\n        error: e,\n        sid: data.sid,\n      });\n    }\n  }\n\n  static async callSendMethodFormat(\n    event: MessageEvent<{ data: IWalletCustomSendOptions & { sid: string } }>,\n    callback: SendBack,\n  ) {\n    const data = event.data.data ?? {};\n\n    try {\n      const { contractOptions, functionName, privateKey, paramsOption, sendOptions } = data;\n\n      const missParams = getMissParams({\n        functionName,\n        contractOptions,\n        privateKey,\n      });\n\n      if (missParams) throw `Miss Param: ${missParams}`;\n      const account = aelf.getWallet(privateKey);\n      (contractOptions as IEOAInstanceOptions).account = account;\n      const contract = await getContractBasic(contractOptions as any);\n      const req = await contract.callSendMethod(functionName, account.address, paramsOption, sendOptions);\n\n      return callback(event, { code: SandboxErrorCode.success, message: req, sid: data.sid });\n    } catch (e: any) {\n      callback(event, {\n        code: SandboxErrorCode.error,\n        error: handleErrorMessage(e),\n        sid: data.sid,\n      });\n    }\n  }\n\n  static async callViewMethodFormat(\n    event: MessageEvent<{ data: ICustomViewOptions & { sid: string } }>,\n    callback: SendBack,\n  ) {\n    const data = event.data.data ?? {};\n\n    try {\n      const { contractOptions, functionName, paramsOption, callOptions } = data;\n      const missParams = getMissParams({\n        functionName,\n        contractOptions,\n      });\n\n      if (missParams) throw `Miss Param: ${missParams}`;\n      const account = aelf.getWallet(COMMON_PRIVATE);\n      (contractOptions as IEOAInstanceOptions).account = account;\n      const contract = await getContractBasic(contractOptions as any);\n      const req = await contract.callViewMethod(functionName, paramsOption, callOptions);\n      return callback(event, { code: SandboxErrorCode.success, message: req, sid: data.sid });\n    } catch (e: any) {\n      callback(event, {\n        code: SandboxErrorCode.error,\n        error: handleErrorMessage(e),\n        sid: data.sid,\n      });\n    }\n  }\n\n  static async encodedTx(\n    event: MessageEvent<{ data: Omit<IWalletCustomSendOptions, 'sendOptions'> & { sid: string } }>,\n    callback: SendBack,\n  ) {\n    const data = event.data.data ?? {};\n\n    try {\n      const { contractOptions, functionName, privateKey, paramsOption } = data;\n\n      const missParams = getMissParams({\n        functionName,\n        contractOptions,\n      });\n\n      if (missParams) throw Error(`Miss Param: ${missParams}`);\n      const account = aelf.getWallet(privateKey);\n      (contractOptions as IEOAInstanceOptions).account = account;\n      const contract = await getContractBasic(contractOptions as any);\n      const result = await contract.encodedTx(functionName, paramsOption);\n      console.log(result, 'result===');\n      return callback(event, { code: SandboxErrorCode.success, message: result, sid: data.sid });\n    } catch (e: any) {\n      callback(event, {\n        code: SandboxErrorCode.error,\n        error: handleErrorMessage(e),\n        sid: data.sid,\n      });\n    }\n  }\n}\n\nnew SandboxUtil();\n"],"names":["SandboxEventTypes","getBalances","callViewMethod","callSendMethod","getTransactionFee","getTransactionRaw","callCASendMethod","callSendMethodFormat","callViewMethodFormat","encodedTx","SandboxErrorCode","error","success","EventEmitter","SandboxEventService","static","event","data","eleId","iframe","document","getElementById","sleep","createElement","sid","uuid","v4","replace","contentWindow","postMessage","source","eventName","origin","Promise","resolve","window","addEventListener","dispatchKey","dispatch","listen","handleErrorMessage","errorText","handleError","handleContractError","message","getMissParams","obj","_key","Object","entries","reverse","map","key","value","COMMON_PRIVATE","aelf","getWallet","contracts","accountContracts","caContracts","SandboxUtil","constructor","this","listener","response","dispatchToOrigin","async","callback","rpcUrl","address","privateKey","_contract","getContractBasic","contractAddress","account","caContractAddress","caHash","callType","methodName","paramsOption","chainType","result","_getELFViewContract","code","sendOptions","missParams","contract","getCAContract","req","transactionId","e","isGetSignTx","_getELFSendContract","raw","aelfInstance","getAelfInstance","aelfContract","instance","functionName","transaction","FetchRequest","send","url","method","params","RawTransaction","Success","TransactionFee","contractOptions","callOptions","Error"],"mappings":"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"}